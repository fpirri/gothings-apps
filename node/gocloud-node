#!/bin/bash
#                                                                    2020-03-12
#    GOTHINGS CLOUD:  servizio WP
                                                                 VERSION="0.01.04"
#
#  Vedi doc in:
#    .../WP-Sviluppi/gothings/README.gothings.cloud

#===================================================================
#
#
# ----------------------------------
# Define config variables
MENUNAME="NODE"
MENUTAG="${MENUNAME} v${VERSION}"
#
echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ${MENUTAG}"
echo
echo "Versione TEMPORANEA per usare gli script locali manualmente ..."
echo "type 'exit' to close terminal & return back"
echo
echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ $HOSTNAME"
echo "Apro un terminale locale"
echo
bash
exit
#
#
#
#
#
#
#
#
#
#
#===================================================================
#
#  Versione TEMPORANEA per sviluppare la versione GENERICA della APP
#    generica  -->  parte esecutiva indipendente dal nome della APP
#                   <-- la app viene letta da github ed eseguita su una qualunque droplet
#
#  1. si gira la versione temporanea fino a che non fuziona correttamente
#  2. si sdoppia in due: prefisso + coda generica
#     <-- il prefisso esegue il settaggio di tutte le variabili, poi si esegue la coda
#  3. + di una coda ??
#  ====> FINE!
#    per ora siamo ancora al 2
#
#  ==> STRUTTURARE MEGLIO:
#    AGGIUSTARE I MENU per lavorare con stringhe "versionabili"
#
#
####################################################################################################
#####     GOCLOUD-WP  -  sezioni definite:
#
#                                                                             GOCLOUD-WP  config
#                                                                            GOCLOUD-APP  generic
#                                                                            GOCLOUD-APP  verify
#                                                                            GOCLOUD-APP  base logic
#                                                                            GOCLOUD-APP  main logic
#                                                                            GOCLOUD-APP  menu
#
####################################################################################################
#
#
#
#
#==============================================================================
echo
echo "====================================================== GOTHINGS for cloud"
echo "      Control loader for GOTHINGS CLOUD docker system."
echo "========================================================================="
echo
#
####################################################################################################
########################################################################     GOCLOUD-WP  config  ###
####################################################################################################
#
# definizione droplets:
#
#  echo "gothings-v09        Public: 104.248.95.29     Local: 10.133.94.60"    <--  DB
#  echo "gothings-v01-03     Public: 188.166.70.203    Local: 10.133.3.65"     <--  BASE  &  WP
#
APPNAME="wp"
DISPLAYNAME="Wordpress"
DROPLET=(hostname)
DROPNAME="gothings-v01-03"
DROPADDR="188.166.70.203"
PRIVATEIP="10.133.3.65"

USERNAME=yesfi
HOMEDIR="/home/${USERNAME}/"
DIRSDIR="dockrepo/dockimages/dirs/"
INSTALLDIR="${HOMEDIR}dockrepo/dockimages/"                      #  dir dei file di configurazione
FILEEXPAND="${INSTALLDIR}${APPNAME}/${APPNAME}expand.json"       #  file di configurazione della fase expand
FILEINIT="${INSTALLDIR}${APPNAME}/${APPNAME}init.json"
FILEINSTALL="${INSTALLDIR}${APPNAME}/${APPNAME}install.json"

#
#
####################################################################################################
#######################################################################   GOCLOUD-APP  generic   ###
####################################################################################################
#
#
# ----------------------------------
# Define variables
#
EDITOR=nano
PASSWD=/etc/passwd
RED='\033[0;41;30m'
STD='\033[0;0;39m'
GITHUBHOME="https://raw.githubusercontent.com/fpirri/" #      :   prefisso per i progetti fpirri su github
#
#  GITHUBPATH  :  gothings-cloud/blob/master/                 :   repository da scaricare        $2
#  LOCALPATH   :  dockrepo/dockimages/cloud/                  :   path del file                  $3
#                                                                 identici su github e su raspi
#  nome file   :    cloudinstall.json                         :   nome file da scaricare        $1
#
#-----------------   GLOBAL da ridefinire
DEBUGLOG=""
ERRCODE=""
ERRFILE=""
RETLEVEL=0  # 0 : tutto OK; 1+ : situazione non valida ...
ITEXISTS=0  # 1 se il cercato esiste, 0 altrimenti
FILE=""     # Nome del file in fileexists()
MENUTRAP=0  #  66 : exit menu

cd ${HOMEDIR} #work on user <USERNAME>  home

# ----------------------------------
# User defined functions
# ----------------------------------
#
##########################################################################
dots(){
  # wait $1 seconds, printing dots on the screen
  #   $1 :  # of seconds to wait
  local param1
  printf -v param1 '%d\n' $1 2>/dev/null # converti in intero con tutti i controlli
  while [ $param1 -gt 0 ]
  do
    echo -n "."
    sleep 0.5
    echo -n "."
    sleep 0.5
    let "--param1"
  done
}
#
##########################################################################
avanti(){
  # Domanda di continuazione personalizzabile
  # call:    avanti $1
  #   $1:    "<stringa di domanda>"
  echo "----------------------------------------------------------------"
  read -rsp "$1" -n 1 key
  echo
}
#
##########################################################################
pause(){
#  Domanda 'continue or exit'
  avanti 'Press any key to continue or ^C to exit ...'
}
#
##########################################################################
notavailable(){
  #  Funzione prevista, ma ancora DA FARE
  echo
  echo "----------------------------------------------------------------"
  echo "Unfortunately, this function is planned, but not available yet."
  echo "Please retry later ..."
  echo
  pause
}
#
##########################################################################
functiontodo(){
  # BOH!  Questa funzione e' ancora DA FARE
  echo 
  echo
  echo "----------------------------------------------------------------"
  echo "La funzione ancora non c'e'"
  echo
  echo "Qui ci sara' una funzione, quando sara' fatta ..."
  echo
  #exit
  pause "?"
}
#
##########################################################################
toupdate(){
  #  segnala funzione IN CORSO DI MODIFICA
  echo 
  echo
  echo "------------------------------------------------------------ ???:"
  echo
  echo "This function is WORK IN PROGRESS"
  echo "A new definition & rewriting is on course"
  echo
  #exit
  pause "?"
}
#
##########################################################################
errmessage(){
  #  $1 :  nome del file non trovato
  #  $2 :  avviso all'utente, come '... il file xxx e' essenziale ...'
  echo 
  echo "------------------------------------------------------"
  echo -e "${RED} ERROR on file: $1 - debug message: ${STD}"
  echo $DEBUGLOG
  echo -e "$2"
  echo "------------------------------------------------------"
  echo 
}
#
##########################################################################
stopmenu(){
  #  $1 :  nome del file non trovato
  #  $2 :  avviso all'utente, come '... il file xxx e' essenziale ...'
  errmessage "$1" "$2"
  echo "Cannot continue."
  echo 
  MENUTRAP=66
  RETLEVEL=66
  ERRFILE=$1
  return 66
}
#
##########################################################################
showsubtitle(){
  # 1. SHOW submenu header
  #
  # call:    showsubtitle $1
  #    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  # $1:"         Sub menu title"
  #
  clear
  echo 
  echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  echo "$1"
  echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
}
#
##########################################################################
bugmessage(){
  # stampa $debuglog ed un avviso di errore
  #
  #  $1 :  ERROR oppure WARNING
  #  $2 :  codice di errore
  #  stampa piccola storia  <-- debuglog
  #  $3 :  avviso all'utente, come '... il file xxx e' essenziale ...'
  echo 
  echo "------------------------------------------------------"
  echo -e "${RED} $1 $2 - debug message: ${STD}"
  echo ${debuglog}
  echo -e "$3"
  echo "------------------------------------------------------"
  echo 
}
#
##########################################################################
json2string() {
  # Trasforma valori json da stringa in stringa nulla
  #   $1    nome variabile da verificare
  typeset -n ref1=$1 #                    ref1 punta alla variabile json
  case "$ref1" in #                       check valori anomali --> stringa ""
    null|true|false)
      ref1=""
      echo "null value"
      return 0
      ;;
    *)
      echo "value: $ref1"
      return 1
  esac
}
#
##########################################################################
#
showcontainers(){
  # 1. SHOW containers status
  #               "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  #  showsubtitle "         sottotitolo piu' o meno centrato"
  #
  local max count
  max=10
  count=15 # deve essere: count > max
  while true; do
    count=$((count+1))
    if [[ count -ge max ]]; then
      clear
      count=0
      showsubtitle "      MANAGE:  SHOW all containers"
      echo -en "\033[6;0H"
    fi
    docker ps -a --format "table {{.Names}}\\t{{.Image}}\\t{{.Status}}"
    echo "----------------------------------------------------------------- ${count}   "
    echo -n "                             Press any key to return at main menu                   "
    echo -n "                                                                                    "
    echo -en "\033[6;0H"
    read -t 3 -N 1 input
    if [ $? == 0 ]; then
      echo "Back to main menu"
      break 
    fi
  done
}
#
##########################################################################
getgitfile(){    # Lettura file da github
  # Verify file existence, get it from github if not
  #    eventually, make it executable  (input var $4=="EXEC")
  #
  #  use globals:
  #    DEBUGLOG=""     # utile nel debug
  #    ITEXISTS=0      #  1 : file esiste    0 : file assente
  #
  #
  #     <-- se esiste il file $1 ed ha lunghezza > 0 :
  #         <-- si va avanti senza altre azioni
  #     <-- altrimenti si prova a scaricare il file da github               AGGIUSTARE dopo ......
  #     <-- si riprova il test di lunghezza
  #         se non funziona si torna con ITEXISTS=0
  #     
  # call :    findnodeapp $1 $2 $3 [$4]
  #   $1 :    "nomefile"
  #   $2 :    "github project branch"   <-- togliere la 'location'==="https://github.com/fpirri/"
  #   $3 :    "local path after $HOMEDIR"   <--   local path===github path 
  #   $4 :    optional input variable, make file executable if value is "EXEC"
  #        --> attenti alle barre inizio-fine--> $1: no-no ;  $2: no-si ;  $3: no-si
  # RETURN:
  #           ITEXISTS = 1 se esiste, 0 altrimenti
  #####
  # example:
  #          getgitfile "gotdirs.tar.gz" "gothings-install/master/" "dockrepo/sysarchive/"
  #
  #  bash:  -s file  True if file exists and has a size greater than zero
  #############################################  DEBUG info:
  echo "getgitfile() debug info"
  echo '  $1  nomefile : ' $1
  echo '  $2  github project branch : ' $2
  echo '  $3  local path : ' $3
  echo '  $4  option var : ' $4
  #####
  #
  local filegit githubfile
  #
  FILEGIT="${HOMEDIR}$3$1"
  DEBUGLOG="|| getgitfile() INFO || Il file cercato e': $FILEGIT"
  if [[ -s $FILEGIT ]]; then
    ITEXISTS=1    # file exists and length > 0
    DEBUGLOG="$DEBUGLOG | $FILEGIT esiste |"
  else            # si prova a scaricarlo
    githubfile="${GITHUBHOME}$2$3$1"
    DEBUGLOG="$DEBUGLOG | $FILEGIT does not exist | download githubfile: $githubfile |"
    wget -O "$FILEGIT" "$githubfile"
    if [[ -s $FILEGIT ]]; then
      ITEXISTS=1    # file exists and length > 0
      DEBUGLOG="$DEBUGLOG | $FILEGIT trovato |"
      if [ "$4" == "EXEC" ]; then      # option: make it executable
        chmod +x "$FILEGIT"
      fi
    else
      ITEXISTS=0    # file introvabile !
      DEBUGLOG="$DEBUGLOG | $FILEGIT introvabile |"
      echo $DEBUGLOG                               ########### Stampa sempre mentre sviluppo ...
    fi
  fi
  return $ITEXISTS
}
#
##########################################################################
consoleexit() {
  #  Return to shell
  echo
  echo
  echo "---------------------------------------------------------"
  echo "Thank you for using   G O T H I N G S   C L O U D   MENU"
  echo
  MENUTRAP=0
  exit 0
}
#
##########################################################################
terminal(){
  # Apri un terminale in questa droplet
  echo
  echo "----------------------------------------------------------------"
  echo "Open a terminal on this droplet"
  echo "                                      <-- Type 'exit' to go back"
  echo
  bash
  echo
  echo " going back ..."
  dots 1
}
#
####################################################################################################
#######################################################################     GOCLOUD-APP  verify  ###
####################################################################################################
#
#
##########################################################################       versione 2020-03-12

####------------------------------------------------------------------ application dependencies ...\

verifyexpand() {

#### versione per Wordpress  -  generalizzazione da verificare

  #  si verifica <appname>expand.json per vedere se l'espansione e' da fare,
  #  ovvero se e' gia' fatta o non e' comunque necessaria:
  #
  #  ritorna 0 se l'operazione non ha prodotto errori
  #          1 se ci sono stati errori ...
  #
  #  error details in:  .../github-gothings/README.github.gothings
  #
  #  il dir .../dockimages/<appname> DEVE contenere il file di configurazione <appname>expand.json
  #  nello stesso dir sono eventualmente presenti i files <appname>expand.sh e <appname>dirs.tar.gz
  #  TUTTE le info necessarie sono nel .json
  #
  local filejson status filetargz githubgzfile script temp debuglog nvar
  filejson="${HOMEDIR}dockrepo/dockimages/${APPNAME}/${APPNAME}expand.json"
  #
  echo "    <-- configuration data read from ${filejson}"
  temp=($(cat "${filejson}" | jq -r '.status,.filetargz,.githubgzfile,.script'))
  # verifica che se ci sono null!!
  echo "    <--       status: ${temp[0]}"
  echo "    <--   filetar.gz: ${temp[1]}"
  echo "    <-- githubgzfile: ${temp[2]}"
  echo "    <--       script: ${temp[3]}"
  # aggiusta le variabili, se necessario
  nvar=0
  status=${temp[0]}
  json2string status
  (( nvar += $? ))
  filetargz=${temp[1]}
  json2string filetargz
  (( nvar += $? ))
  githubgzfile=${temp[2]}
  json2string githubgzfile
  (( nvar += $? ))
  if [[ "${nvar}" -ne 3 ]]; then
    debuglog="ERROR 1 - JSON file ${filejson} returned some null values"
    bugmessage ERROR 1 "    JSON returned invalid values"
    return 1 #                                                                 ERROR 1: Invalid JSON
  fi
  echo "    <-- non-null variables: ${nvar}"
  # verifica stringhe nulle
  temp=$((${#temp} * ${#status} * ${#filetargz} * ${#githubgzfile}))
  if [[ "${temp}" -eq 0 ]]; then
    debuglog="ERROR 2 - JSON returned empty string"
    bugmessage ERROR 2 "    JSON file ${filejson} returned empty string"
    return 2 #                                                                 ERROR 2: Invalid JSON
  fi
  # valori apparentemente accettabili, andiamo avanti
  echo "    <-- variable types OK"
  filetargz="${HOMEDIR}${filetargz}"
  echo "    <-- sysdata for ${DISPLAYNAME} environment read from ${filetargz}"
  debuglog="|| verify expand |"
  case "${status}" in
    todo) #                                      expand archive .tar.gz
      echo "    <--  expand to be done"
      if [[ -s "${filetargz}" ]]; then # file exists and length > 0
        debuglog="${debuglog}| ${filetargz} esiste |"
      else #                             il file non esiste, proviamo a scaricarlo
        debuglog="${debuglog}| ${filetargz} does not exist | download githubgzfile: ${githubgzfile} |"
        wget -O "${filetargz}" "${githubgzfile}"
        if [[ -s "${filetargz}" ]]; then
          debuglog="${debuglog}| ${filetargz} trovato |" #  il file e' stato trovato e verra' espanso
          echo "    <--  archive file exists"
        else
          debuglog="{$debuglog}| ${filetargz} introvabile |"
          bugmessage ERROR 66 "    file not found"
          return 66
        fi
      fi
      echo "    <--  expand archive file"
      sudo tar xpf "${filetargz}" -C "$HOMEDIR" #   si espande l'archivio
      temp=$?
      if [[ ! $temp -eq 0 ]]; then
        debuglog="{$debuglog}| ${filetargz} expansion failed! - return: ${temp} | ERROR 66"
        bugmessage ERROR 66 "    archive expansion failed"
        return 66
      fi
      # espansione effettuata:  aggiorna il .json
      echo
      echo "    <-- expand OK, change .json status from 'todo' to 'done'"
      echo "$(cat "${filejson}" | jq -r '.status |= "done"')" > "${filejson}.new"
      temp=$?
      echo "    <-- save existing file into 'old'"
      cp -r "${filejson}"  "${filejson}.old"
      echo "    <-- copy 'new' file onto ${APPNAME}expand.json"
      cp -r "${filejson}.new"  "${filejson}"
      echo -n "    <-- verify <appname>expand.json status :"
      temp=($(cat ${filejson} | jq -r '.status'))
      echo ${temp}
      if [ "${temp}" != "done" ]; then
        bugmessage WARNING 5 "    ERROR : can't update ${filejson} file"
        return 5
      fi
      echo "    <-- .json status update OK"
      echo "    ------------------------------"
      ;;
    done)
      echo "    <-- expand not needed"
      ;;
    *)
      bugmessage WARNING 3 "    ERROR 3 - JSON status value is invalid"
      return 3
      ;;
  esac
  return 0
  echo "1- questo non verra' MAI stampato!"
}
#
##########################################################################       versione 2020-03-20
verifyinit() {
  #  si verifica ${APPNAME}init.json per vedere se c'e' una inizializzazione da fare,
  #  ovvero se e' gia' fatta o non e' comunque necessaria:
  #
  #  ritorna 0 se l'operazione non ha prodotto errori
  #          1 se ci sono stati errori ...
  #
  #  error details in:  .../github-gothings/README.github.gothings
  #
  #  il dir .../dockimages/${APPNAME} DEVE contenere il file di configurazione ${APPNAME}init.json
  #  il .json mantiene lo status dell'inizializzazione ( todo / done )
  #
  #  il dir .../docksecrets/${APPNAME} DEVE contenere il file di configurazione .env-${APPNAME}
  #  questo file sara' quello effettivamente usato per la creazione del container
  #
  #
  local filejson status script temp nvar
  filejson="${HOMEDIR}dockrepo/dockimages/${APPNAME}/${APPNAME}init.json"
  #  file github:
  #    https://github.com/fpirri/gothings-cloud-apps/blob/master/dockrepo/dockimages/${APPNAME}/${APPNAME}init.json
  #
  echo "    <-- configuration data read from ${filejson}"
  ################## ???  script="${HOMEDIR}dockrepo/sysdata/${APPNAME}/${APPNAME}init.sh"
  #
  temp=($(cat "${filejson}" | jq -r '.status,.script'))
  # aggiusta le variabili, se necessario
  nvar=0
  status=${temp[0]}
  json2string status
  (( nvar += $? ))
  script=${temp[1]}
  json2string script
  (( nvar += $? ))
  if [[ "${nvar}" -ne 2 ]]; then
    debuglog="ERROR 1 - JSON file ${filejson} returned some null values"
    bugmessage ERROR 1 "    JSON returned invalid values"
    return 1 #                                                                 ERROR 1: Invalid JSON
  fi
  echo "    <-- non-null variables: ${nvar}"
  # verifica stringhe nulle
  #echo "Lunghezze ---  temp: ${#temp} | status: ${#status} | script: ${#script}"
  temp=$((${#temp} * ${#status} * ${#script}))
  if [[ "${temp}" -eq 0 ]]; then
    debuglog="ERROR 2 - JSON returned empty string"
    bugmessage ERROR 2 "    JSON file ${filejson} returned empty string"
    return 2 #                                                                 ERROR 2: Invalid JSON
  fi
  # verifica la variabile status
  echo "    <-- read status from json file ${filejson}"
  debuglog="|| verify init |"
  case "${status}" in
    todo) #                                                                    init ${APPNAME} to do
      if [[ -s "${script}" ]]; then # file exists and length > 0
        debuglog="|${debuglog}| ${script} esiste |"
      else
        debuglog="|${debuglog}| init script ${script} not found |"
        bugmessage ERROR 66 "    file not found"
        return 66 #                                                 il file non esiste  -->  ERRORE 4
      fi
      ########################                il file esiste, possiamo continuare l'inizializzazione
      #
      ##########################################  VERICA esistenza .env, se no: STOP
      echo "    <-- copy secrets from origin to working dir"
      cp dockrepo/docksecrets/${APPNAME}/.env-${APPNAME} dockrepo/sysdata/${APPNAME}/.env-${APPNAME}
      # now you can init !
      echo "    <-- exec ${script} ..."
      . ${script} # esegui lo script di init come se incluso in questo script
      echo
      echo "    <-- ${script} return code: ${RETVALUE}"
      ############  come si tiene conto di ERRCOUNT per db ???
      if [ "${RETVALUE}" -gt 0 ]; then # errore nello script
        if [ "${RETVALUE}" -eq "666" ]; then # set codice errore
          ERRCODE=72
      else
          ERRCODE=71
        fi
        debuglog="|${debuglog}| init script return value: ${RETVALUE} |"
        bugmessage ERROR ${ERRCODE}"    init script execution error"
        return ${ERRCODE}
      else
        # init done : update .json file
        echo
        echo "    <-- update .json status from 'todo' to 'done'"
        echo "$(cat "${filejson}" | jq -r '.status |= "done"')" > "${filejson}.new"
        temp=$?
        echo "    <-- save existing file into 'old'"
        cp -r "${filejson}"  "${filejson}.old"
        echo "    <-- copy 'new' file onto ${APPNAME}init.json"
        cp -r "${filejson}.new"  "${filejson}"
        echo -n "    <-- verify ${APPNAME}init.json status : "
        temp=($(cat ${filejson} | jq -r '.status'))
        echo ${temp}
        if [ "${temp}" != "done" ]; then
          bugmessage ERROR 5 "    ERROR : can't update ${filejson} file"
          return 5 #                                         update JSON file failed!  -->  ERRORE 5
        fi
      fi
      echo "    <-- .json status update OK"
      echo "    ------------------------------"
      ;;
    done)
      echo "    OK - init not required"
      ;;
    *)
      bugmessage ERROR 3 "    ERROR 3 - JSON status value is invalid"
      return 0
      ;; #                                                                     ERROR 3: Invalid JSON
  esac
  echo "    INIT phase OK"
  return 0
}
#
##########################################################################       versione 2019-11-20
verifyinstall() {
  #  si verifica cloudinstall.json per vedere se l'espansione e' da fare,
  #  ovvero se e' gia' fatta o non e' comunque necessaria:
  #
  #  ritorna 0 se l'operazione non ha prodotto errori
  #          1 se ci sono stati errori ...
  #
  #  error details in:  .../github-gothings/README.github.gothings
  #
  #  il dir .../dockimages/cloud DEVE contenere il file di configurazione cloudinstall.json
  #  il .json mantiene lo status dell'installazione ( todo / done )
  #
  #
  local filejson status script temp nvar xscript
  filejson="${HOMEDIR}dockrepo/dockimages/${APPNAME}/${APPNAME}install.json"
  #  file github:
  #    https://github.com/fpirri/gothings-cloud/blob/master/dockrepo/dockimages/dirs/${APPNAME}install.json
  #
  echo "    <-- configuration data read from ${filejson}"
  ################## ???  script="${HOMEDIR}dockrepo/sysdata/cloud/cloudinstall.sh"
  #
  temp=($(cat "${filejson}" | jq -r '.status,.script'))
  # aggiusta le variabili, se necessario
  nvar=0
  status=${temp[0]}
  json2string status
  (( nvar += $? ))
  script=${temp[1]}
  json2string script
  (( nvar += $? ))
  if [[ "${nvar}" -ne 2 ]]; then
    debuglog="ERROR 1 - JSON file ${filejson} returned some null values"
    bugmessage ERROR 1 "    JSON returned invalid values"
    return 1 #                                                                 ERROR 1: Invalid JSON
  fi
  echo "    <-- non-null variables: ${nvar}"
  # verifica stringhe nulle
  #echo "Lunghezze ---  temp: ${#temp} | status: ${#status} | script: ${#script}"
  temp=$((${#temp} * ${#status} * ${#script}))
  if [[ "${temp}" -eq 0 ]]; then
    debuglog="ERROR 2 - JSON returned empty string"
    bugmessage ERROR 2 "    JSON file ${filejson} returned empty string"
    return 2 #                                                                 ERROR 2: Invalid JSON
  fi
  # verifica la variabile status
  echo "    <-- read status from json file ${filejson}"
  echo "status: ${status}"
  xscript="${HOMEDIR}${script}"
  echo "xscript: ${xscript}"
  debuglog="|| verify install |"
  case "${status}" in
    todo) #                                                                       install cloud to do
      if [[ -s "${xscript}" ]]; then # file exists and length > 0
        debuglog="${debuglog}| ${xscript} esiste |"
      else
        debuglog="${debuglog}| install script ${xscript} not found |"
        bugmessage ERROR 66 "    file not found"
        return 66 #                                                 il file non esiste  -->  ERRORE 4
      fi
      ######################## do install :
      echo "    <-- exec ${xscript} ..."
      . ${xscript} # esegui lo script di install
      echo
      echo "    <-- ${script} return code: ${RETVALUE}"
      if [ "${RETVALUE}" -gt 0 ]; then # errore nello script
        if [ "${RETVALUE}" -eq "666" ]; then # set codice errore
          ERRCODE=82
      else
          ERRCODE=81
        fi
        debuglog="|${debuglog}| init script return value: ${RETVALUE} |"
        bugmessage ERROR ${ERRCODE}"    init script execution error"
        return ${ERRCODE}
      else
        # install done : update .json file
        echo
        echo "    <-- update .json status from 'todo' to 'done'"
        echo "$(cat "${filejson}" | jq -r '.status |= "done"')" > "${filejson}.new"
        temp=$?
        echo "    <-- save existing file into 'old'"
        cp -r "${filejson}"  "${filejson}.old"
        echo "    <-- copy 'new' file onto cloudinstall.json"
        cp -r "${filejson}.new"  "${filejson}"
        echo -n "    <-- verify cloudinstall.json status : "
        temp=($(cat ${filejson} | jq -r '.status'))
        echo ${temp}
        if [ "${temp}" != "done" ]; then
          bugmessage ERROR 5 "    ERROR : can't update ${filejson} file"
          return 5 #                                         update JSON file failed!  -->  ERRORE 5
        fi
      fi
      echo "    <-- .json status update OK"
      echo "    ------------------------------"
      ;;
    done)
      echo "    OK - install not required"
      ;;
    *)
      bugmessage ERROR 3 "    ERROR 3 - JSON status value is invalid"
      return 0
      ;; #                                                                     ERROR 3: Invalid JSON
  esac
  echo "    INSTALL phase OK"
  return 0
}
#
##########################################################################
verifyenv() {
#  Verifica che i file .env-* siano tutti aggiornati !!!!!
# ci si accerta che le password iniziali sul sito siano cambiate
  echo
  echo
  echo "---------------------------------------------------------"
  echo "Verify security environment on this computer"
  echo
  echo "Per ora e' una finzione ..."
  echo "simulo che vada tutto bene!"
  echo "----- DA FARE -----"
  echo
  dots 1
  echo
  return 0
}
#
####################################################################################################
##################################################################     GOCLOUD-APP  base logic   ###
####################################################################################################
#
#
##########################################################################
startapp() {
#  START APPLICATION
  echo
  echo
  echo "---------------------------------------------------------"
  echo "Use docker-compose to START ${DISPLAYNAME} container"
  echo
  echo "Starting docker-compose ..."
  docker-compose -f "${HOMEDIR}dockrepo/sysdata/${APPNAME}/gothings${APPNAME}.yml" up -d
  dots 1
  echo "Done."
}
#
##########################################################################
#  STOP APPLICATION
pauseapp() {
  echo
  echo
  echo "---------------------------------------------------------"
  echo "Use docker-compose to STOP ${DISPLAYNAME} container"
  echo
  echo "This operation will STOP your ${DISPLAYNAME} container"
  echo "You can re-run it with the START operation."
  echo "Permanent user data will NOT be destroyed"
  read -rsp "Do you like to STOP ${DISPLAYNAME} container? [y/N] " -n 1 key
  case "$key" in
      [yY]) 
        echo
        echo "Using docker-compose to stop ${DISPLAYNAME} container ..."
        export 
        docker-compose -f "${HOMEDIR}dockrepo/sysdata/${APPNAME}/gothings${APPNAME}.yml" stop
        echo
        dots 1
        echo "done."
        ;;
      *)
        echo
        echo "Back to choice"
        dots 1
        ;;
  esac
}
#
##########################################################################
destroyapp() {
#  DESTROY APPLICATION
  echo
  echo
  echo "---------------------------------------------------------"
  echo "Use docker-compose to STOP & DESTROY ${DISPLAYNAME} container"
  echo 
  echo "------------------ ATTENTION, please,"
  echo "This operation will STOP & DESTROY your running ${DISPLAYNAME} container !"
  echo "Anyway you can re-create and run it with the START operation."
  echo "Permanent user data will NOT be destroyed"
  read -rsp "Do you like to STOP & DESTROY? [y/N] " -n 1 key
  case "$key" in
      [yY]) 
        echo
        echo "Using docker-compose to stop & destroy ${DISPLAYNAME} container ..."
        docker-compose -f "${HOMEDIR}dockrepo/sysdata/${APPNAME}/gothings${APPNAME}.yml" down
        echo
        dots 2
        echo "done."
        ;;
      *)
        echo
        echo "Back to choice"
        dots 1
        ;;
  esac
}
#
##########################################################################
destroyall() {
# CLEAR service
  echo
  echo "---------------------------------------------------------"
  echo 
  echo "   -------------- ATTENTION, please, ---------------"
  echo "   *** This operation is WORK-IN-PROGRESS ***"
  echo "   There will be changes in the near future ..."
  echo
  echo "This script clear the existing ${DISPLAYNAME} installation, i.e. it"
  echo -e "will ${RED}  TOTALLY DESTROY ${STD} the ${DISPLAYNAME} installation"
  echo "All content and configuration will be deleted"
  echo -e "Every permanent information will be ${RED} DESTROYED ${STD}"
  echo
  RETVAL=$(docker ps -a --format "table {{.Names}}" | grep ${APPNAME})
  echo "Search for ${APPNAME} service ..."
  echo
  if [ "$RETVAL" = "$APPNAME" ]; then
    # caso 1:  il container db esiste, NON possiamo procedere
    echo
    echo "Before performing such operation, ${APPNAME} container"
    echo "should be destroyed"
    echo
    echo "Please, first DESTROY  the ${APPNAME} container then retry"
    echo
    pause
  else
    # caso 2:  il container <appname> non esiste, procediamo
    echo
    echo -e "This script will TOTALLY DESTROY the ${DISPLAYNAME} installation!"
    echo -e "   ${RED} All content and configuration data will be DELETED  ${STD}"
#
#   TODO
#     - fare copia di backup PRIMA del clear
#       per l'eventuale ripristino
#     - dare istruzioni web per il ripristino
#
    echo -e "   ${RED}         this operation IS NOT RECOVERABLE          ${STD}"
    echo
    echo "Please note: I may ask for your sudo password"
    read -rsp "Do you like to CLEAR ? [y/N] " -n 1 key
    case "$key" in
      [yY]) 
        echo "     <-- verify bash script exists" #                                        ancora DA FARE
        # TODO
        echo "     <-- exec CLEAR operation on ${DISPLAYNAME}"
        dockrepo/sysdata/${APPNAME}/${APPNAME}config/${APPNAME}clear.sh
        ERRTYPE=$?
        # error 127 --> lo script non esiste
        # error 126 --> permission denied
        # verificare eventuali altri errori !!!!!!!!!!!!!!!!
        echo "    <-- CLEAR operation returns code ${ERRTYPE}"
        if [ ${ERRTYPE} -gt 0 ]; then
          MENUTRAP=73
        fi
        ;;
      *)
        echo
        echo
        echo "CLEAR operation NOT performed"
        sleep 2
        ;;
    esac
  fi
  echo
  echo "Back to menu"
  sleep 1
}
#
####################################################################################################
##################################################################     GOCLOUD-APP  main logic   ###
####################################################################################################
#
echo
echo "Verify GOTHINGS CLOUD software installation ..."
#
echo "    verify ${DISPLAYNAME} directories ..."
#
#
#################################################################################
################################################################  set directories
#
####------------------------------------------------------------------ application dependencies ...\
if [[ ! -s "${HOMEDIR}dockrepo" ]]; then
  mkdir dockrepo/
fi
if [[ ! -s "${HOMEDIR}dockrepo/dockimages" ]]; then
  mkdir dockrepo/dockimages
fi
if [[ ! -s "${HOMEDIR}dockrepo/dockimages/dirs" ]]; then
  mkdir dockrepo/dockimages/dirs
fi
if [[ ! -s "${HOMEDIR}dockrepo/dockimages/${APPNAME}" ]]; then
  mkdir dockrepo/dockimages/${APPNAME}
fi
if [[ ! -s "${HOMEDIR}dockrepo/dockimages/${APPNAME}/var_www_html" ]]; then
  mkdir dockrepo/dockimages/${APPNAME}/var_www_html
fi
if [[ ! -s "${HOMEDIR}dockrepo/sysdata" ]]; then
  mkdir dockrepo/sysdata
fi
####------------------------------------------------------------------ application dependencies .../
#
#################################################################################
###################################################################  phase EXPAND
echo
echo
echo "-------------------------------"
echo "    EXPAND phase starts ..."
echo "      verify ${APPNAME} expand config file ..."
#
FILECONF="${FILEEXPAND}"       #  file di configurazione della fase expand
# assicurati che il file di configurazione esista
getgitfile "${APPNAME}expand.json" "gothings-cloud-apps/master/${APPNAME}/" "dockrepo/dockimages/${APPNAME}/"
ITEXISTS=$?
if [[ $ITEXISTS -ne 1 ]]; then
  echo "      <-- configuration install file DOES NOT exists."
  stopmenu "${FILECONF}"  "file ${FILECONF} is essential for GoThings CLOUD"
  exit                       # interrommpere il menu principale
fi
echo "      <-- exists, verifying content ..." 
#
verifyexpand
#
#----  verifica parte expand
# - si verifica ${APPNAME}install.json per vedere se l'espansione e' da fare,
#    ovvero se e' gia' fatta o non e' comunque necessaria:
#
#  ritorna:  0  se l'operazione expand non ha prodotto errori
#           !0  se ci sono stati errori ...
#
#  error details in:  .../github-gothings/README.github.gothings
#
MENUTRAP=$?
echo
if [ ${MENUTRAP} -gt 0 ]; then
  echo -e "    ${RED}  <-- expand phase returns code ${MENUTRAP}  ${STD}"
else
  echo -e "    <-- expand phase returns code ${MENUTRAP}"
fi
echo
echo "###############################"
echo "          EXPAND phase done."
echo
if [ ${MENUTRAP} -eq 0 ]; then
#
#################################################################################
#####################################################################  phase INIT
  echo
  echo "-------------------------------"
  echo "    INIT phase starts ..."
  echo "      verify ${APPNAME} init config file ..."
  #
  FILECONF="${FILEINIT}"       #  file di configurazione della fase init
  # assicurati che il file di configurazione esista
  getgitfile "${APPNAME}init.json" "gothings-cloud-apps/master/${APPNAME}/" "dockrepo/dockimages/${APPNAME}/"
  ITEXISTS=$?
  if [[ $ITEXISTS -ne 1 ]]; then
    echo "      <-- configuration install file DOES NOT exists."
    stopmenu "${FILECONF}"  "file ${FILECONF} is essential for GoThings CLOUD"
    exit                       # interrommpere il menu principale
  fi
  echo "      <-- exists, verifying content ..." 
  #
  verifyinit
  #
  #----  verifica parte init
  # - si verifica <appname>init.json per vedere se ci sono operazioni da fare,
  #    ovvero se sono gia' state fatte o non sono comunque necessarie:
  #
  #  ritorna:  0  se l'operazione init non ha prodotto errori
  #           !0  se ci sono stati errori ...
  #
  #  error details in:  .../github-gothings/README.github.gothings
  #
  MENUTRAP=$?
  echo
  if [ ${MENUTRAP} -gt 0 ]; then
    echo -e "    ${RED}  <-- expand phase returns code ${MENUTRAP}  ${STD}"
  else
    echo -e "    <-- expand phase returns code ${MENUTRAP}"
  fi
  echo
  echo "###############################"
  echo "          INIT phase done."
  echo
#
fi
if [ ${MENUTRAP} -eq 0 ]; then
#
#################################################################################
##################################################################  phase INSTALL
  echo
  echo "-------------------------------"
  echo "    INSTALL phase starts ..."
  echo "      verify ${APPNAME} install config file ..."
  #
  FILECONF="${FILEINSTALL}"       #  file di configurazione della fase install
  # assicurati che il file di configurazione esista
  getgitfile "${APPNAME}install.json" "gothings-cloud-apps/master/${APPNAME}/" "dockrepo/dockimages/${APPNAME}/"
  ITEXISTS=$?
  if [[ $ITEXISTS -ne 1 ]]; then
    echo "      <-- configuration install file DOES NOT exists."
    stopmenu "${FILECONF}"  "file ${FILECONF} is essential for GoThings CLOUD"
    exit                       # interrommpere il menu principale
  fi
  echo "      <-- exists, verifying content ..." 
  #
  verifyinstall
  #
  #----  verifica parte install
  # - si verifica <appname>install.json per vedere se ci sono operazioni da fare,
  #    ovvero se sono gia' state fatte o non sono comunque necessarie:
  #
  #  ritorna:  0  se l'operazione install non ha prodotto errori
  #           !0  se ci sono stati errori ...
  #
  #  error details in:  .../github-gothings/README.github.gothings
  #
  MENUTRAP=$?
  echo
  if [ ${MENUTRAP} -gt 0 ]; then
    echo -e "    ${RED}  <-- install phase returns code ${MENUTRAP}  ${STD}"
  else
    echo -e "    <-- install phase returns code ${MENUTRAP}"
  fi
  echo
  echo "###############################"
  echo "          INSTALL phase done."
  echo
fi
if [ ${MENUTRAP} -eq 0 ]; then
#
#################################################################################
####################################################  verify security environment
#
#----  verifica security environment:  si cercano i file .env-* in sysdata
#  questi DEVONO essere diversi da quanto memorizzato nella fase expand
#
#  - si cerca 'filetargz' usato nella fase expand
#  - al suo interno si cercano i file '.env-*'
#  - si crea un file di controllo
#  - si verifica che i valori nel file .env-* siano diversi dagli originali ...
#  - ci si blocca se non va bene
#  ---> alternativa:  cercare il nome file nel <compose>.yml
#
#  ritorna:  0  se l'operazione environment non ha prodotto errori
#           !0  se ci sono stati errori ...
#
#  error details in:  .../github-gothings/README.github.gothings
#
  echo
  echo "-------------------------------"
  echo "    Verify environments ..."
  echo
  verifyenv
  MENUTRAP=$?
  echo
  if [ ${MENUTRAP} -gt 0 ]; then
    echo -e "    ${RED}  <-- environment phase returns code ${MENUTRAP}  ${STD}"
  else
    echo -e "    <-- environment phase returns code ${MENUTRAP}"
  fi
  echo
  echo "###############################"
  echo "     ENVIRONMENT phase done."
  echo
fi
echo
echo "---------------------------------------"
echo "  CONTINUE to the menu functions ..."
#
# CONTINUE to the menu functions
#
##########################################################################
displayerrors() {
  #  $1       MENUTRAP:  # di errore
  #  $1       ERRTYPE:   codice mnemonico
  echo "------------------------------------------------------"
  echo -e "${RED}  GOTHINGS Control Menu got errors!  ${STD}"
  echo "------------------------------------------------------"
  echo "ERROR CODE NUMBER: $1"
  echo -n "ERROR TYPE: "
  case $1 in
    82) echo "User stopped VERIFY INSTALL phase of gocloud-${APPNAME}"
        ;;
    81) echo "Error in VERIFY INSTALL phase of gocloud-${APPNAME}"
        ;;
    73) if [[ "$2" -eq "127" ]]; then
          echo "${APPNAME}clear.sh does not exist"
        elif [[ "$2" -eq "126" ]]; then
          echo "permission denied executing ${APPNAME}clear.sh"
        else
          echo "unknown error executing ${APPNAME}clear.sh"
        fi
        # error 127 --> lo script non esiste
          # error 126 --> permission denied
        ;;
    72) echo "User stopped VERIFY INIT phase of gocloud-${APPNAME}"
        ;;
    71) echo "Error in VERIFY INIT phase of gocloud-${APPNAME}"
        echo "ERROR COUNTER is $2"
        ;;
    69) echo "------------------------------------------------------"
        echo "          failure from SIMULATOR got"
        echo "------------------------------------------------------"
        echo
        ;;
    67) echo "------------------------------------------------------"
        echo "GOTHINGS Control Menu was downloaded from github,"
        echo "------------------------------------------------------"
        echo
        ;;
    66)     echo 
        echo "----------------------------------------------------------------"
        echo " UNRECOVERABLE error"
        echo
        echo " GOCLOUD did not find the essential file ${ERRFILE}"
        echo " Please review All your configuration files"
        echo
        echo "----------------------------------------------------------------"
        echo
        ;;
    *)  echo "UNKNOWN ERROR verifying gocloud-${APPNAME} configuration"
  esac
}
####################################################################################################
########################################################################     GOCLOUD-APP  menu   ###
####################################################################################################
#
#
#==============================================================================
echo
echo "========================================================== GOTHINGS CLOUD"
echo "        Loading ${DISPLAYNAME} menu ..."
echo "========================================================================="
echo
#
dots 1
#
##########################################################################
# function to display menus
show_menus() {
  clear
  echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ${APPNAME} v${VERSION}"
  echo
  echo "    GOTHINGS:   ${DISPLAYNAME} MENU"
  echo
  echo -n "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ "
  hostname
  echo
  echo "1. SHOW      container's status"
  echo "2. START     ${DISPLAYNAME} container"
  echo "3. PAUSE     ${DISPLAYNAME} container"
  echo "4. DESTROY   ${DISPLAYNAME} container"
  echo "   ---          future work"
  #echo "5. ---         work todo"
  #echo "6. ---         work todo"
  echo "7. CLEAR     ${DISPLAYNAME} service"
  echo "8. TERM      open terminal here"
  echo "9. UPDATE    this menu"
  echo "0. EXIT      return to console"
}
#
# read input from the keyboard and take a action
# invoke the function according to the entered number
read_options(){
	local choice
  read -rsp $'Enter choice [ 1..9 or ^C to exit ] ' -n 1 choice
	case "$choice" in
		1) showcontainers;;
    2) startapp;;
		3) pauseapp;;
		4) destroyapp;;
		5) toupdate;;
		6) toupdate;;
		7) destroyall;;
		8) terminal;;
		9) notavailable;;   #updatethismenu;;
    0) consoleexit;;
		*) echo -e "${RED}Error...${STD}" && sleep 2
	esac
}
# ----------------------------------------------
# Step #3: Trap CTRL+C, CTRL+Z and quit singles
# ----------------------------------------------
trap '' SIGQUIT SIGTSTP
#trap '' SIGINT SIGQUIT SIGTSTP
# -----------------------------------
# Step #4: Main logic - infinite loop
# ------------------------------------
#
while true
do
  # internal trap
  if [[ ${MENUTRAP} -gt 0 ]]; then
    displayerrors ${MENUTRAP} ${ERRTYPE}
    break  #-- stop menu   
  fi
	show_menus
	read_options
done
echo
echo "Shell terminated."
echo
#
